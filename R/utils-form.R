#' Convert character to formula object
#'
#' @param x [`character`] text.
#'
#' @keywords utils
#'
#' @noRd
#'
#' @keywords internal
to_formula <- function(formula){
  # Convert to formula object
  if(!is.null(formula)) {
    formula = stats::as.formula(formula)
  } else {
    # Asign a new waiver object
    formula = new_waiver()
  }
  return(formula)
}

#' Get terms from a formula object
#'
#' @param formula A [`formula`] or [`character`] object.
#'
#' @keywords utils
#'
#' @noRd
#'
#' @keywords internal
formula_terms <- function(formula){
  # Check
  assertthat::assert_that(
    is.character(formula) || inherits(formula, "formula")
  )
  if(formula == "<Default>") stop("Default formula found!")
  if(!inherits(formula, "formula")) formula <- stats::as.formula(formula)
  # Get the terms from the formula
  te <- attr(stats::terms.formula(formula), "term.labels")
  return(te)
}

#' Logistic (invlogit) transformation function
#'
#' @param x A [`numeric`] value.
#'
#' @keywords utils
#'
#' @noRd
#'
#' @keywords internal
logistic <- function(a){
  if(is.data.frame(a)){
    apply(a, 2, function(x) ilink(x, link = "logit") )
  } else {
    ilink(a, link = "logit")
  }
}

#' Logistic Richard curve
#' @description This function uses the five parameters logistic curve proposed
#' by Richards (1959) and suggested by Merow et al. (2017) as a way to weight
#' the expert knowledge. The equation associated to this logistic curve is
#'
#' \deqn{W(x) = u - \frac{u - l}{\left(1 + e^{-r(x-k)}\right)^{1/s}}}{W(x) = u -
#' (u - l)/((1 + exp(-r(x-k)))^(1/s))}. where eqn{u} and eqn{l} are the upper
#' and lower asymptotes of the logistic curve, eqn{r} is a rate that gives
#' flexibility to the curve from a sharpe step to a flat surface and eqn{s} is a
#' measure of skewness that adjust the symmetry of the decay on the edge of the
#' expert map. As for eqn{k}, it shifts the curve inside or outside the expert
#' map. Finally, eqn{x} is the provided vector.
#'
#' @param x A [`numeric`] vector or any other input (e.g. [`SpatRaster`]) that can
#' be used in the Richard's function.
#' @param lower A [`numeric`] of the lower asymptote.
#' @param upper A [`numeric`] of the upper asymptote.
#' @param rate A [`numeric`] of the rate.
#' @param skew A [`numeric`] of the skew.
#' @param shift A [`numeric`] of the shift.
#'
#' @references
#' * Richards, F. J. 1959. A flexible growth function for empirical use. Journal of
#'  Experimental Botany 10 :290â€“301
#'
#' @keywords utils
#' @concept bossMaps
#'
#' @noRd
#'
#' @keywords internal
logisticRichard <- function(x, lower = 1, upper = 1, rate = 1, skew = 1,
                            shift = 1) {
  # Check
  assertthat::assert_that(
    is.numeric(lower), is.numeric(upper),
    is.numeric(rate), is.numeric(skew),
    is.numeric(shift),
    skew > 0
  )

  # Fit curve
  y <- upper - ((upper - lower)/((1 + exp(-rate * (x - shift)))^(1/skew)))
  return(y)
}

#' Logit transformation function
#'
#' @param x A [`numeric`] value.
#'
#' @keywords utils
#'
#' @noRd
#'
#' @keywords internal
logit <- function(a){
  if(is.data.frame(a)){
    apply(a, 2, function(x) log(x/(1-x))  )
  } else {
    log(a/(1-a))
  }
}

#' Inverse transformation function for the link function
#'
#' @description back transforms a [numeric] vector using the appropriate link function
#'
#' @param x A [`numeric`] vector generated by a model
#' @param link [`character`] indicating the link function to use (Default: \code{"log"}).
#'
#' @examples
#' ilink(rpois(10,.7), link = "log")
#'
#' @noRd
#'
#' @keywords internal
ilink <- function(x, link = "log"){
  assertthat::assert_that(is.numeric(x),
                          is.character(link)
  )
  link <- match.arg(link, c("identity", "log","logm1","log1p",
                            "inverse", "sqrt", "logit", "probit",
                            "cauchit", "cloglog") , several.ok = FALSE)
  switch (link,
          identity = x,
          log = exp(x),
          logm1 = exp(x) + 1,
          log1p = expm1(x),
          inverse = 1/x,
          sqrt = x^2,
          logit = ( 1 / (1 + exp(-x)) ),
          probit = stats::pnorm(x),
          cauchit = stats::pcauchy(x),
          cloglog = (1 - exp(-exp(x)))
  )
}

#' Combine or concatenate multiple formula objects
#'
#' @description
#' This small helper function allows to combine multiple `formula()` objects
#' into one. In the case of duplicate variable entries, only the unique ones
#' are used.
#'
#' @details
#' Use "y ~ 0" to specify a stand alone LHS.
#'
#' @note
#' This likely won't work for interaction terms (such as \code{*} or \code{:}).
#' @param ... Any number [`formula`] objects in "LHS ~ RHS" format, also supporting
#' [`character`] strings.
#' @param combine [`character`] on whether LHS and RHS duplicates are to be removed. Can
#' be set to either \code{"lhs"}, \code{"rhs"} or \code{"both"} (Default).
#' @param env A new environment of the formula \code{(def=parent.frame())}.
#' @returns A formula as \code{cbind(lhs_1, lhs_2, ...) ~ rhs_1 + rhs_2 + ...} or
#' \code{lhs ~ rhs_1 + rhs_2} in case of identical LHS (see examples).
#'
#' @keywords utils
#'
#' @examples
#' # Combine everything (default)
#' combine_formulas(observed ~ rainfall + temp, observed ~ rainfall + forest.cover)
#' # Combine only LHS
#' combine_formulas(observed ~ rainfall + temp, observed ~ rainfall + forest.cover, combine = "lhs")

#' @export
combine_formulas <- function(..., combine = "both", env=parent.frame()) {
  assertthat::assert_that(
    is.character(combine)
  )
  combine <- match.arg(combine, choices = c("rhs", "lhs", "both"),several.ok = FALSE)
  # drop "~" and extract left/right hand sides (LHS/RHS)
  obj <- lapply(list(...), function(.) as.character(as.formula(.))[-1])
  rhs <- mapply(`[`, obj, lengths(obj) - 0, SIMPLIFY=FALSE)
  lhs <- mapply(`[`, obj, lengths(obj) - 1, SIMPLIFY=FALSE)

  # Handle the RHS
  rhs <- rhs[sapply(rhs, `!=`, "0")] # drop "0"
  # Check for interaction terms
  chki <- lapply(rhs, function(z) length(grep("*", z, fixed = TRUE))>0)
  if(any(unlist(chki))) stop("Interaction terms found. Formula combination does not work for these cases!")

  if(any(c("rhs", "both") %in% combine)){
    un <- unlist(rhs)
    rhs <- Map(`[`, rhs, relist(!duplicated(un), skeleton = rhs))
  }  else {
    rhs <- do.call(paste, c(rhs, sep=" + "))
  }
  # use "0" if rhs is empty
  if(length(rhs) < 1) rhs <- "0"

  # Handle LHS
  lhs <- lhs[lengths(lhs) > 0] # drop empty(s)
  if(any(c("lhs", "both") %in% combine)) lhs <- unique(lhs)
  if(length(lhs) > 1) lhs <- sprintf("cbind(%s)", do.call(paste, c(lhs, sep=", ")))

  # Return "lhs ~ rhs" as a formula in the calling environment.
  suppressWarnings(
    f <- as.formula(paste0(lhs, " ~ ", rhs), env)
  )
  return( f )
}

#' Create formula matrix
#'
#' @description
#' Function to create list of formulas with all possible combinations of
#' variables
#'
#' @param form An input [`formula`] object.
#' @param response A [`character`] object giving the response. (Default: \code{NULL})
#' @param type Currently implemented are \code{'inla'} (variable groups), \code{'All'}
#' (All possible combinations) or \code{'forward'}.
#'
#' @returns A [`vector`] object with [`formula`] objects.
#'
#' @keywords utils
#'
#' @examples
#' \dontrun{
#' formula_combinations(form)
#' }
#'
#' @noRd
#'
#' @keywords internal
formula_combinations <- function(form, response = NULL, type= 'forward'){
  assertthat::assert_that(is.formula(form),
                          is.character(response) || is.null(response),
                          tolower(type) %in% c('inla','forward','all'))
  # --- #
  # Response
  if(is.null(response)) response <- all.vars(form)[1]
  # Formula terms
  te <- attr(stats::terms.formula(form),'term.label')
  # Varnames
  varnames <- all.vars(form)
  varnames <- varnames[varnames %notin% c('spde','spatial.field','observed','Intercept')] # Exclude things not necessarily needed in there
  # Variable length
  fl <- length(varnames)
  # --- #
  assertthat::assert_that(fl>0, !is.null(response))

  if(tolower(type) == 'inla'){
    # INLA modelling groups
    # Instead of selecting variables piece by piece, consider individual groups
    form_temp <- c()
    val_int <- grep(pattern = 'Intercept',x = te, value = T)
    val_lin <- grep(pattern = 'linear',x = te, value = T)
    val_rw1 <- grep(pattern = 'rw1',x = te,value = TRUE)
    # Alternative quadratic variables in case rw1 fails
    if(length(val_rw1)>0){
      val_quad <- all.vars(stats::as.formula(paste('observed ~ ', paste0(val_rw1,collapse = '+'))))[-1]
    } else { val_quad <- all.vars(stats::as.formula(paste('observed ~ ', paste0(val_lin,collapse = '+'))))[-1] }
    val_spde <- grep(pattern = 'spde',x = te,value = TRUE)
    val_ofs <- grep(pattern = 'offset',x = te,value = TRUE)

    # Construct formulas ---
    # Original form
    form_temp <- c(form_temp, deparse1(form))

    # Intercept only
    form_temp <- c(form_temp,
                   paste0(response,' ~ 0 +', paste(val_int,collapse = ' + ') ))

    # Add all linear variables as base
    form_temp <- c(form_temp,
                   paste0(response,' ~ 0 +', paste(val_int,collapse = ' + '),
                          '+', paste0(varnames, collapse = ' + ') ))

    # Intercept + linear effect
    if(length(val_lin)>0){
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_lin,collapse = ' + '))
      )
    }
    # Intercept + rw1 effects (if existing)
    if(length(val_rw1)>0){
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_rw1,collapse = ' + '))
      )
    }
    # Alternative formulation using quadratic
    form_temp <- c(form_temp,
                   paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                          '+',
                          paste0('I(',val_quad,'^2)',collapse = ' + '))
    )

    # Intercept + spde
    if(length(val_spde)>0){
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_spde,collapse = ' + '))
      )
    }
    # Intercept + linear + spde
    if(length(val_spde)>0 && length(val_lin)>0){
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_spde,collapse = ' + '),'+',paste(val_lin,collapse = ' + '))
      )
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 +', paste(val_int,collapse = ' + '),
                            '+', paste0(varnames, collapse = ' + '),
                            '+',paste(val_spde,collapse = ' + ')))

    }
    # intercept + rw1 + spde
    if(length(val_spde)>0 && length(val_rw1)>0){
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_spde,collapse = ' + '),'+',paste(val_rw1,collapse = ' + '))
      )
    }
    if(length(val_spde)>0){
      # Quad replacement
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_spde,collapse = ' + '),'+',paste0('I(',val_quad,'^2)',collapse = ' + '))
      )
    }
    # intercept + linear + rw1 + spde
    if(length(val_rw1)>0 && length(val_lin)>0 && length(val_spde)>0){
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_lin,collapse = ' + '),'+',paste(val_rw1,collapse = ' + '),'+',paste(val_spde,collapse = ' + '))
      )

    }
    if(length(val_spde)>0){
      # Quad replacement
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_lin,collapse = ' + '),'+',paste0('I(',val_quad,'^2)',collapse = ' + '),'+',paste(val_spde,collapse = ' + '))
      )
    }
    # intercept + linear + offset
    if(length(val_lin)>0 && length(val_ofs)>0){
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_lin,collapse = ' + '),'+',paste(val_ofs,collapse = ' + '))
      )
    }
    # intercept + linear + rw1 + offset
    if(length(val_rw1)>0 && length(val_lin)>0 && length(val_ofs)>0){
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_lin,collapse = ' + '),'+',paste(val_rw1,collapse = ' + '),'+',paste(val_ofs,collapse = ' + '))
      )
    }
    if(length(val_lin)>0 && length(val_ofs)>0){
      # Quad replacement
      form_temp <- c(form_temp,
                     paste0(response,' ~ 0 + ', paste(val_int,collapse = ' + '),
                            '+',
                            paste(val_lin,collapse = ' + '),'+',
                            paste0('I(',val_quad,'^2)',collapse = ' + '),'+',paste(val_ofs,collapse = ' + '))
      )
    }

    # Other types of variable selection
  } else if(tolower(type) == 'forward'){
    # Forward variable addition
    # Note this ignores unique combinations
    form_temp <- c()
    for(i in 1:fl) {
      new <- paste0(response, '~ 0 + ',paste(val_int,collapse = '+'),'+',
                    paste(varnames[1:i],collapse = ' + ') )
      form_temp <- c(form_temp, new)
    }

  } else if(tolower(type) == 'all'){
    # Construct all possible unique combinations
    varnames_comb <- lapply(1:length(varnames), function(i){
      utils::combn(varnames, i) |> apply(2, list) |> unlist(recursive = F)
    })|> unlist(recursive = F)

    form_temp <- lapply(varnames_comb, function(i) {
      paste0(response, " ~ ", paste(val_int,collapse = '+'),'+', paste(i, collapse = " + "))
    })
  }

  return(form_temp)
}
